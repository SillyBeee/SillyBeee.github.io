{"title":"基于OpenCV的相机软防抖","uid":"ebaa4a924ab8e8b5b45edc965a35412f","slug":"基于OpenCV的相机软防抖","date":"2024-11-15T04:40:49.000Z","updated":"2024-11-15T11:09:48.145Z","comments":true,"path":"api/articles/基于OpenCV的相机软防抖.json","keywords":null,"cover":"/img/cv.png","content":"<h1 id=\"1-识别抖动\"><a href=\"#1-识别抖动\" class=\"headerlink\" title=\"1.识别抖动\"></a>1.识别抖动</h1><p>寻找帧之间的移动，这是算法中最关键的部分。我们将遍历所有的帧，并找到当前帧和前一帧之间的移动。欧几里得运动模型要求我们知道两个坐标系中两个点的运动。但是在实际应用中，找到50-100个点的运动，然后用它们来稳健地估计运动模型。</p>\n<p>特征跟踪首先需要识别出易跟踪的特征，光滑的区域不利于跟踪，而有很多角的纹理区域则比较好。OpenCV有一个快速的特征检测器goodFeaturesToTrack，可以检测最适合跟踪的特性。</p>\n<p>我们在前一帧中找到好的特征，就可以使用Lucas-Kanade光流算法在下一帧中跟踪它们。它是利用OpenCV中的calcOpticalFlowPyrLK函数实现的。</p>\n<p>接着估计运动，我们已经找到了特征在当前帧中的位置，并且我们已经知道了特征在前一帧中的位置。所以我们可以使用这两组点来找到映射前一个坐标系到当前坐标系的刚性（欧几里德）变换。这是使用函数estimateRigidTransform完成的。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 检测前一帧的特征点</span></span><br><span class=\"line\">prev_pts = cv2.goodFeaturesToTrack(prev_gray,</span><br><span class=\"line\">                                   maxCorners=<span class=\"number\">200</span>,</span><br><span class=\"line\">                                   qualityLevel=<span class=\"number\">0.01</span>,</span><br><span class=\"line\">                                   minDistance=<span class=\"number\">30</span>,</span><br><span class=\"line\">                                   blockSize=<span class=\"number\">3</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 读下一帧</span></span><br><span class=\"line\">success, curr = cap.read()</span><br><span class=\"line\"><span class=\"keyword\">if</span> <span class=\"keyword\">not</span> success:</span><br><span class=\"line\">    <span class=\"keyword\">break</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 转换为灰度图</span></span><br><span class=\"line\">curr_gray = cv2.cvtColor(curr, cv2.COLOR_BGR2GRAY)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 计算光流(即轨迹特征点)</span></span><br><span class=\"line\">curr_pts, status, err = cv2.calcOpticalFlowPyrLK(</span><br><span class=\"line\">    prev_gray, curr_gray, prev_pts, <span class=\"literal\">None</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 检查完整性</span></span><br><span class=\"line\"><span class=\"keyword\">assert</span> prev_pts.shape == curr_pts.shape</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 只过滤有效点</span></span><br><span class=\"line\">idx = np.where(status == <span class=\"number\">1</span>)[<span class=\"number\">0</span>]</span><br><span class=\"line\">prev_pts = prev_pts[idx]</span><br><span class=\"line\">curr_pts = curr_pts[idx]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 找到变换矩阵</span></span><br><span class=\"line\"><span class=\"comment\"># 只适用于OpenCV-3或更少的版本吗</span></span><br><span class=\"line\"><span class=\"comment\"># m = cv2.estimateRigidTransform(prev_pts, curr_pts, fullAffine=False)</span></span><br><span class=\"line\">m, inlier = cv2.estimateAffine2D(prev_pts, curr_pts, )</span><br></pre></td></tr></table></figure>\n<h1 id=\"2-计算帧间的平滑运动\"><a href=\"#2-计算帧间的平滑运动\" class=\"headerlink\" title=\"2.计算帧间的平滑运动\"></a>2.计算帧间的平滑运动</h1><p>在前面的步骤中，我们估计帧之间的运动并将它们存储在一个数组中。我们现在需要通过叠加上一步估计的微分运动来找到运动轨迹。</p>\n<p>轨迹计算，在这一步，我们将增加运动之间的帧来计算轨迹。我们的最终目标是平滑这条轨迹，可以很容易地使用numpy中的cumsum(累计和)来实现。</p>\n<p>计算平滑轨迹，我们计算了运动轨迹。所以我们有三条曲线来显示运动(x, y，和角度)如何随时间变化。</p>\n<p>平滑任何曲线最简单的方法是使用移动平均滤波器（moving average filter）。顾名思义，移动平均过滤器将函数在某一点上的值替换为由窗口定义的其相邻函数的平均值。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">movingAverage</span>(<span class=\"params\">curve, radius</span>):</span><br><span class=\"line\">    window_size = <span class=\"number\">2</span> * radius + <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"comment\"># 定义过滤器</span></span><br><span class=\"line\">    f = np.ones(window_size) / window_size</span><br><span class=\"line\">    <span class=\"comment\"># 为边界添加填充</span></span><br><span class=\"line\">    curve_pad = np.lib.pad(curve, (radius, radius), <span class=\"string\">&#x27;edge&#x27;</span>)</span><br><span class=\"line\">    <span class=\"comment\"># 应用卷积</span></span><br><span class=\"line\">    curve_smoothed = np.convolve(curve_pad, f, mode=<span class=\"string\">&#x27;same&#x27;</span>)</span><br><span class=\"line\">    <span class=\"comment\"># 删除填充</span></span><br><span class=\"line\">    curve_smoothed = curve_smoothed[radius:-radius]</span><br><span class=\"line\">    <span class=\"comment\"># 返回平滑曲线</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> curve_smoothed</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">smooth</span>(<span class=\"params\">trajectory</span>):</span><br><span class=\"line\">    smoothed_trajectory = np.copy(trajectory)</span><br><span class=\"line\">    <span class=\"comment\"># 过滤x, y和角度曲线</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">3</span>):</span><br><span class=\"line\">        smoothed_trajectory[:, i] = movingAverage(</span><br><span class=\"line\">            trajectory[:, i], radius=SMOOTHING_RADIUS)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> smoothed_trajectory</span><br></pre></td></tr></table></figure>\n<p>计算平滑变换<br>到目前为止，我们已经得到了一个平滑的轨迹。在这一步，我们将使用平滑的轨迹来获得平滑的变换，可以应用到视频的帧来稳定它。</p>\n<p>这是通过找到平滑轨迹和原始轨迹之间的差异，并将这些差异加回到原始的变换中来完成的。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 使用累积变换和计算轨迹</span></span><br><span class=\"line\">trajectory = np.cumsum(transforms, axis=<span class=\"number\">0</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 创建变量来存储平滑的轨迹</span></span><br><span class=\"line\">smoothed_trajectory = smooth(trajectory)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 计算smoothed_trajectory与trajectory的差值</span></span><br><span class=\"line\">difference = smoothed_trajectory - trajectory</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 计算更新的转换数组</span></span><br><span class=\"line\">transforms_smooth = transforms + difference</span><br></pre></td></tr></table></figure>\n<h1 id=\"3-将平滑的摄像机运动应用到帧中\"><a href=\"#3-将平滑的摄像机运动应用到帧中\" class=\"headerlink\" title=\"3.将平滑的摄像机运动应用到帧中\"></a>3.将平滑的摄像机运动应用到帧中</h1><p>现在我们所需要做的就是循环帧并应用我们刚刚计算的变换。如果我们有一个指定为(x, y, θ),的运动，对应的变换矩阵是：</p>\n<p>$$<br>T &#x3D; \\begin{bmatrix}<br>\\cos\\theta &amp; -\\sin\\theta &amp; x \\<br>\\sin\\theta &amp; \\cos\\theta &amp; y \\<br>\\end{bmatrix}<br>$$</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 从新的转换数组中提取转换</span></span><br><span class=\"line\">dx = transforms_smooth[i, <span class=\"number\">0</span>]</span><br><span class=\"line\">dy = transforms_smooth[i, <span class=\"number\">1</span>]</span><br><span class=\"line\">da = transforms_smooth[i, <span class=\"number\">2</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 根据新的值重构变换矩阵</span></span><br><span class=\"line\">m = np.zeros((<span class=\"number\">2</span>, <span class=\"number\">3</span>), np.float32)</span><br><span class=\"line\">m[<span class=\"number\">0</span>, <span class=\"number\">0</span>] = np.cos(da)</span><br><span class=\"line\">m[<span class=\"number\">0</span>, <span class=\"number\">1</span>] = -np.sin(da)</span><br><span class=\"line\">m[<span class=\"number\">1</span>, <span class=\"number\">0</span>] = np.sin(da)</span><br><span class=\"line\">m[<span class=\"number\">1</span>, <span class=\"number\">1</span>] = np.cos(da)</span><br><span class=\"line\">m[<span class=\"number\">0</span>, <span class=\"number\">2</span>] = dx</span><br><span class=\"line\">m[<span class=\"number\">1</span>, <span class=\"number\">2</span>] = dy</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 应用仿射包装到给定的框架</span></span><br><span class=\"line\">frame_stabilized = cv2.warpAffine(frame, m, (w, h))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Fix border artifacts</span></span><br><span class=\"line\">frame_stabilized = fixBorder(frame_stabilized)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 将框架写入文件</span></span><br><span class=\"line\">frame_out = frame_stabilized</span><br><span class=\"line\">out.write(frame_out)</span><br></pre></td></tr></table></figure>\n<p>修复边界伪影<br>当我们稳定一个视频，我们可能会看到一些黑色的边界伪影。这是意料之中的，因为为了稳定视频，帧可能不得不缩小大小。我们可以通过将视频的中心缩小一小部分(例如4%)来缓解这个问题。</p>\n<p>下面的fixBorder函数显示了实现。我们使用getRotationMatrix2D，因为它在不移动图像中心的情况下缩放和旋转图像。我们所需要做的就是调用这个函数时，旋转为0，缩放为1.04(也就是提升4%)。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">fixBorder</span>(<span class=\"params\">frame</span>):</span><br><span class=\"line\">    s = frame.shape</span><br><span class=\"line\">    <span class=\"comment\"># 在不移动中心的情况下，将图像缩放4%</span></span><br><span class=\"line\">    T = cv2.getRotationMatrix2D((s[<span class=\"number\">1</span>] / <span class=\"number\">2</span>, s[<span class=\"number\">0</span>] / <span class=\"number\">2</span>), <span class=\"number\">0</span>, <span class=\"number\">1.04</span>)</span><br><span class=\"line\">    frame = cv2.warpAffine(frame, T, (s[<span class=\"number\">1</span>], s[<span class=\"number\">0</span>]))</span><br><span class=\"line\">    <span class=\"keyword\">return</span> frame</span><br></pre></td></tr></table></figure>\n","feature":true,"text":"1.识别抖动寻找帧之间的移动，这是算法中最关键的部分。我们将遍历所有的帧，并找到当前帧和前一帧之间的移动。欧几里得运动模型要求我们知道两个坐标系中两个点的运动。...","permalink":"/post/基于OpenCV的相机软防抖","photos":[],"count_time":{"symbolsCount":"3.6k","symbolsTime":"3 mins."},"categories":[],"tags":[{"name":"OpenCV","slug":"OpenCV","count":1,"path":"api/tags/OpenCV.json"},{"name":"C++","slug":"C","count":1,"path":"api/tags/C.json"},{"name":"Python","slug":"Python","count":1,"path":"api/tags/Python.json"},{"name":"光流法","slug":"光流法","count":1,"path":"api/tags/光流法.json"},{"name":"特征点匹配","slug":"特征点匹配","count":1,"path":"api/tags/特征点匹配.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#1-%E8%AF%86%E5%88%AB%E6%8A%96%E5%8A%A8\"><span class=\"toc-text\">1.识别抖动</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#2-%E8%AE%A1%E7%AE%97%E5%B8%A7%E9%97%B4%E7%9A%84%E5%B9%B3%E6%BB%91%E8%BF%90%E5%8A%A8\"><span class=\"toc-text\">2.计算帧间的平滑运动</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#3-%E5%B0%86%E5%B9%B3%E6%BB%91%E7%9A%84%E6%91%84%E5%83%8F%E6%9C%BA%E8%BF%90%E5%8A%A8%E5%BA%94%E7%94%A8%E5%88%B0%E5%B8%A7%E4%B8%AD\"><span class=\"toc-text\">3.将平滑的摄像机运动应用到帧中</span></a></li></ol>","author":{"name":"SillyBee","slug":"blog-author","avatar":"/img/mei.png","link":"/","description":"来自杭州电子科技大学的一名大二学生,是Robomaster比赛PHOENIX战队CV成员","socials":{"github":"https://github.com/SillyBeee","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"https://www.zhihu.com/people/42-46-43-3","csdn":"https://blog.csdn.net/SillyBeee?spm=1000.2115.3001.5343","juejin":"https://juejin.cn/user/1634290885471136","customs":{}}},"mapped":true,"hidden":false,"prev_post":{"title":"Ubuntu如何使用Zerotier实现远程串流","uid":"cd3c61450f9ac60e6bfe52ccccb004e4","slug":"ubuntu如何使用zerotier实现远程串流","date":"2024-11-15T15:16:22.000Z","updated":"2024-11-15T15:36:24.315Z","comments":true,"path":"api/articles/ubuntu如何使用zerotier实现远程串流.json","keywords":null,"cover":"/img/zerotier.jpg","text":"本文实现使用平板远程串流电脑环境要求:1.sunshine(ubuntu上) 2.moonlight与zerotier one(平板或手机上) 3.zeroti...","permalink":"/post/ubuntu如何使用zerotier实现远程串流","photos":[],"count_time":{"symbolsCount":"1k","symbolsTime":"1 mins."},"categories":[],"tags":[{"name":"zerotier","slug":"zerotier","count":1,"path":"api/tags/zerotier.json"},{"name":"moonlight","slug":"moonlight","count":1,"path":"api/tags/moonlight.json"},{"name":"sunshine","slug":"sunshine","count":1,"path":"api/tags/sunshine.json"},{"name":"ubuntu","slug":"ubuntu","count":2,"path":"api/tags/ubuntu.json"}],"author":{"name":"SillyBee","slug":"blog-author","avatar":"/img/mei.png","link":"/","description":"来自杭州电子科技大学的一名大二学生,是Robomaster比赛PHOENIX战队CV成员","socials":{"github":"https://github.com/SillyBeee","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"https://www.zhihu.com/people/42-46-43-3","csdn":"https://blog.csdn.net/SillyBeee?spm=1000.2115.3001.5343","juejin":"https://juejin.cn/user/1634290885471136","customs":{}}},"feature":true},"next_post":{"title":"Hello World","uid":"b9663f58f18133b35bfe243f3e916a80","slug":"hello-world","date":"2024-11-13T08:10:41.948Z","updated":"2024-11-15T11:26:18.221Z","comments":true,"path":"api/articles/hello-world.json","keywords":null,"cover":"/img/he.jpg","text":"Welcome to Hexo! This is your very first post. Check documentation for more info...","permalink":"/post/hello-world","photos":[],"count_time":{"symbolsCount":444,"symbolsTime":"1 mins."},"categories":[],"tags":[],"author":{"name":"SillyBee","slug":"blog-author","avatar":"/img/mei.png","link":"/","description":"来自杭州电子科技大学的一名大二学生,是Robomaster比赛PHOENIX战队CV成员","socials":{"github":"https://github.com/SillyBeee","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"https://www.zhihu.com/people/42-46-43-3","csdn":"https://blog.csdn.net/SillyBeee?spm=1000.2115.3001.5343","juejin":"https://juejin.cn/user/1634290885471136","customs":{}}}}}